package com.example.periodtracker;

import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class AESEncryptor {

    private Cipher EncryptCipher;
    private Cipher DecryptCipher;

    public AESEncryptor(SecretKey key) throws IllegalArgumentException {
        try {
            // Create Cipher object for AES with CBC and PKCS5 padding. AES/CBC/PKCS5Padding
            EncryptCipher = Cipher.getInstance("AES");
            DecryptCipher = Cipher.getInstance("AES");
            // Initialise encrypt and decrypt cipher accordingly.
            EncryptCipher.init(Cipher.ENCRYPT_MODE, key);
            DecryptCipher.init(Cipher.DECRYPT_MODE, key);
        } catch (NoSuchAlgorithmException ex) {
            // Not reachable, algorithm exists by java spec.
        } catch (NoSuchPaddingException ex) {
            // Not reachable, padding exists by java spec.
        } catch (InvalidKeyException ex) {
            // Throw new clearer exception as class cannot be created without valid key.
            throw new IllegalArgumentException("Key is invalid. Please provide a valid SecretKey");
        }
    }

    /**
     * Returns a computed secret key of a password using the password and salt.
     * @param   password    the password to be used to generate a key.
     * @param   salt        the salt used to create a different key passwords that are the same.
     *                      32-bytes long and cryptographically random.
     * @return              the secret key generated by hashing the password.
     */
    public static SecretKey generateKey(char[] password, byte[] salt) {
        PBEKeySpec spec = new PBEKeySpec(password, salt, 300000, 256);
        try {
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
            return new SecretKeySpec((keyFactory.generateSecret(spec)).getEncoded(), "AES");
        } catch (NoSuchAlgorithmException ex) {
            // Not reachable, algorithm exists by java spec.
            return null;
        } catch (InvalidKeySpecException ex) {
            // Not reachable, key spec was created by the appropriate object in this context.
            return null;
        }
    }

    /**
     * Encrypts data provided using the AES key that initialised the object.
     * @param   plaintext   data to be encrypted.
     * @return              encrypted data.
     */
    public byte[] Encrypt(byte[] plaintext) {
        try {
            return EncryptCipher.doFinal(plaintext);
        } catch (IllegalBlockSizeException ex) {
            // Not reachable, padding is enabled for encryption therefore input size does not matter.
            return null;
        } catch (BadPaddingException ex) {
            // Not reachable, BadPaddingException can only occur when in decrypt state.
            return null;
        }
    }

    /**
     * Decrypts data provided using the AES key that initialised the object.
     * @param   ciphertext  encrypted data to be decrypted.
     * @return              decrypted data.
     */
    public byte[] Decrypt(byte[] ciphertext) {
        try {
            return DecryptCipher.doFinal(ciphertext);
        } catch (IllegalBlockSizeException ex) {
            // Throw new exception, ciphertext is not correct block size (16 bytes).
            throw new IllegalArgumentException("Cipher text is of invalid size. Please provide correct cipher text.");
        } catch (BadPaddingException ex) {
            // Throw new exception, ciphertext does not have valid PKCS5 padding.
            throw new IllegalArgumentException("Cipher text has invalid padding. Please provide correct cipher text.");
        }
    }

}
